import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Slider } from "@/components/ui/slider";
import { Switch } from "@/components/ui/switch";
import { Textarea } from "@/components/ui/textarea";
import { FileText, Loader2 } from "lucide-react";
import { showError, showSuccess } from "@/utils/toast";
import BlogOutput from "@/components/BlogOutput";
import Header from "@/components/Header";
import Footer from "@/components/Footer";
import { generateBlog, type BlogRequest } from "@/api/generate-blog";

interface ParsedBlogData {
  title: string;
  metaDescription: string;
  keywords: string[];
  markdownContent: string; // The full raw markdown
  htmlContent: string; // This is actually the markdown content for the blog body
}

// Helper function to parse the raw markdown string
const parseMarkdownBlog = (markdown: string, fallbackTopic: string): ParsedBlogData => {
  let title = fallbackTopic; // Use the input topic as a fallback
  let metaDescription = "A detailed blog post generated by AI.";
  let keywords: string[] = [];
  let blogContentMarkdown = "";

  // Regex to find Title, Meta Description, Keywords, and Blog Content sections
  const titleMatch = markdown.match(/^(?:#+\s*)?Title:\s*(.*)/im);
  if (titleMatch && titleMatch[1]) {
    title = titleMatch[1].trim();
  }

  const metaDescriptionMatch = markdown.match(/^(?:#+\s*)?Meta Description:\s*(.*)/im);
  if (metaDescriptionMatch && metaDescriptionMatch[1]) {
    metaDescription = metaDescriptionMatch[1].trim();
  }

  const keywordsMatch = markdown.match(/^(?:#+\s*)?Keywords:\s*(.*)/im);
  if (keywordsMatch && keywordsMatch[1]) {
    keywords = keywordsMatch[1].split(',').map(k => k.trim()).filter(k => k.length > 0);
  }

  // Extract blog content after the "Blog Content:" marker
  const blogContentMatch = markdown.match(/^(?:#+\s*)?Blog Content:\s*([\s\S]*)/im);
  if (blogContentMatch && blogContentMatch[1]) {
    blogContentMarkdown = blogContentMatch[1].trim();
  } else {
    // Fallback: if "Blog Content:" marker is not found, assume everything after keywords is content
    const lastMetadataIndex = Math.max(
      markdown.indexOf(titleMatch ? titleMatch[0] : ''),
      markdown.indexOf(metaDescriptionMatch ? metaDescriptionMatch[0] : ''),
      markdown.indexOf(keywordsMatch ? keywordsMatch[0] : '')
    );
    if (lastMetadataIndex !== -1) {
      blogContentMarkdown = markdown.substring(lastMetadataIndex + (keywordsMatch ? keywordsMatch[0].length : 0)).trim();
    } else {
      blogContentMarkdown = markdown.trim(); // If no markers, treat entire markdown as content
    }
  }

  return {
    title,
    metaDescription,
    keywords,
    markdownContent: markdown, // Store full markdown for export
    htmlContent: blogContentMarkdown, // This will be the markdown part, to be rendered by react-markdown in BlogOutput
  };
};


const BlogGenerator = () => {
  const [topic, setTopic] = useState("");
  const [wordCount, setWordCount] = useState([500]);
  const [batchMode, setBatchMode] = useState(false);
  const [batchTopics, setBatchTopics] = useState("");
  const [blogData, setBlogData] = useState<ParsedBlogData | null>(null);
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setBlogData(null);

    const currentTopic = batchMode ? batchTopics : topic; // Get the topic being used for generation

    try {
      const request: BlogRequest = {
        topic: currentTopic,
        wordCount: wordCount[0],
        batchMode,
      };

      // generateBlog now returns a raw markdown string
      const rawMarkdown = await generateBlog(request);
      const parsedData = parseMarkdownBlog(rawMarkdown, currentTopic); // Pass the current topic here
      setBlogData(parsedData);
      showSuccess("Blog generated successfully!");
    } catch (error: any) {
      console.error("Error generating blog:", error);
      showError(error.message || "Failed to generate blog. Please try again.");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div 
      className="min-h-screen flex flex-col bg-cover bg-center relative"
      style={{ backgroundImage: "url('/pexels-photo-4067695.webp')" }}
    >
      <div className="absolute inset-0 bg-black opacity-70"></div> {/* Dark overlay */}
      <Header />
      <main className="flex-grow max-w-4xl mx-auto w-full relative z-10 py-12 px-4 sm:px-6">
        <div className="text-center mb-12 text-white">
          <h1 className="text-4xl font-bold mb-4">
            BlogGenie AI: Generate Your Blog
          </h1>
          <p className="text-lg max-w-2xl mx-auto">
            Create SEO-optimized blog posts in seconds with the power of AI
          </p>
        </div>

        <Card className="mb-8 bg-gray-800 bg-opacity-80 text-white border-gray-700">
          <CardHeader>
            <CardTitle className="text-white">Generate Your Blog</CardTitle>
          </CardHeader>
          <CardContent>
            <form onSubmit={handleSubmit} className="space-y-6">
              <div className="flex items-center justify-between">
                <Label htmlFor="batch-mode" className="text-gray-200">Batch Mode</Label>
                <Switch
                  id="batch-mode"
                  checked={batchMode}
                  onCheckedChange={setBatchMode}
                  disabled // Disable batch mode for now as it's not supported with raw markdown output
                />
              </div>

              {batchMode ? (
                <div className="space-y-2">
                  <Label htmlFor="batch-topics" className="text-gray-200">Blog Topics (one per line)</Label>
                  <Textarea
                    id="batch-topics"
                    value={batchTopics}
                    onChange={(e) => setBatchTopics(e.target.value)}
                    placeholder="Enter one blog topic per line&#10;Example:&#10;Benefits of AI in Healthcare&#10;Future of Renewable Energy&#10;..."
                    rows={5}
                    required
                    disabled // Disable batch mode for now
                    className="bg-gray-700 text-white border-gray-600 placeholder:text-gray-400"
                  />
                </div>
              ) : (
                <div className="space-y-2">
                  <Label htmlFor="topic" className="text-gray-200">Blog Topic</Label>
                  <Input
                    id="topic"
                    value={topic}
                    onChange={(e) => setTopic(e.target.value)}
                    placeholder="Enter your blog topic..."
                    required
                    className="bg-gray-700 text-white border-gray-600 placeholder:text-gray-400"
                  />
                </div>
              )}

              <div className="space-y-4">
                <div className="flex justify-between">
                  <Label htmlFor="word-count" className="text-gray-200">Word Count: {wordCount[0]}</Label>
                  <span className="text-sm text-gray-400">
                    {wordCount[0]} words
                  </span>
                </div>
                <Slider
                  id="word-count"
                  min={100}
                  max={2000}
                  step={50}
                  value={wordCount}
                  onValueChange={setWordCount}
                  className="w-full [&>span:first-child]:bg-blue-600" // Customizing slider thumb color
                />
                <div className="flex justify-between text-xs text-gray-400">
                  <span>100</span>
                  <span>2000</span>
                </div>
              </div>

              <Button type="submit" className="w-full bg-blue-600 hover:bg-blue-700 text-white" disabled={loading}>
                {loading ? (
                  <>
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                    Generating Blog...
                  </>
                ) : (
                  <>
                    <FileText className="mr-2 h-4 w-4" />
                    Generate Blog
                  </>
                )}
              </Button>
            </form>
          </CardContent>
        </Card>

        {blogData && <BlogOutput blogData={blogData} />}

        <div className="mt-12 text-center text-sm text-gray-400">
          <p className="mb-2">
            <strong>Free OpenRouter Quotas:</strong> New accounts get $1 free credit.
            Check your usage in the OpenRouter dashboard.
          </p>
          <p>
            <strong>Cost Control:</strong> Each request costs approximately $0.0001-0.0003.
            Use batch mode to generate multiple blogs in one request.
          </p>
        </div>
      </main>
      <Footer />
    </div>
  );
};

export default BlogGenerator;